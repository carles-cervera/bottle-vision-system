@startuml SEQUENCE_SYSTEM_CONTROL
!theme plain

title Control d'estat: /system/on i /system/off (watcher en segon pla)

autonumber

actor "Front-end" as FE
participant "FastAPI\n(main.py)" as API
participant "asyncio.Event\n(system_running_event)" as EVT
participant "Watcher task\n(watch_containers)" as WT

== Encendre sistema ==
FE -> API: POST /system/on
activate API

alt system_running ja era True
  API --> FE: 200 OK\n{status:"ON", message:"Ja estava encès"}
else estava OFF
  API -> API: system_running = True
  API -> EVT: set()

  alt hi havia watcher_task actiu
    API -> WT: cancel()
    WT --> API: CancelledError (capturat)
  end

  API -> WT: create_task(watch_containers(...))
  API --> FE: 200 OK\n{status:"ON"}
end

deactivate API

== Apagar sistema ==
FE -> API: POST /system/off
activate API

alt system_running ja era False
  API --> FE: 200 OK\n{status:"OFF", message:"Ja estava apagat"}
else estava ON
  API -> API: system_running = False
  API -> EVT: clear()

  API -> WT: cancel()
  alt WT finalitza abans de 3s
    WT --> API: done
  else timeout 3s
    WT --> API: TimeoutError (log i forçat)
  end

  API --> FE: 200 OK\n{status:"OFF"}
end

deactivate API

note right of API
  Implementació actual:
  /system/off cancel·la el watcher.
  Això no el deixa "en espera" sinó aturat
  fins al següent /system/on.
end note

@enduml
