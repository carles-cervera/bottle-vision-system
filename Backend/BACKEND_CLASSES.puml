@startuml BACKEND_CLASSES
!theme plain

title Backend (FastAPI) — Diagrama de mòduls i classes (fidel al codi)

skinparam linetype ortho
left to right direction
skinparam nodesep 35
skinparam ranksep 45
skinparam classAttributeIconSize 0
hide empty members

' --- External types (minimal) ---
class WebSocket <<external>>
class ThreadPoolExecutor <<external>>
class datetime <<external>>

package "app.websocket_manager" {
  class WebSocketManager {
    connections: list[WebSocket]
    ..
    +connect(ws: WebSocket)
    +disconnect(ws: WebSocket)
    +broadcast(message: dict)
  }

  object manager
  manager : singleton instance

  manager --> WebSocketManager : instance of
}

package "app.main" {
  class MainModule <<module>> {
    system_running: bool
    system_running_event: asyncio.Event
    watcher_task: asyncio.Task
    ..
    +lifespan(app)
    +websocket_endpoint(ws: WebSocket)
    +system_on()
    +system_off()
    +analyze_tap(file)
    +analyze_level(file)
  }
}

package "app.blob_watcher" {
  class BlobWatcher <<module>> {
    processed_blobs: Set[str]
    ..
    +watch_containers(get_system_running_flag, system_running_event)
  }
}

package "app.processor" {
  class BottlePair <<dataclass>> {
    tap_bytes: bytes?
    level_bytes: bytes?
    tap_blob_name: str?
    level_blob_name: str?
    first_seen: datetime
  }

  class Processor <<module>> {
    executor: ThreadPoolExecutor
    bottle_counter: int
    bottles: dict[str, BottlePair]
    ..
    +process_image(container: str, blob_name: str)
    +process_bottle_from_blobs(bottle_id: str, tap_blob_name: str, level_blob_name: str)
    +process_complete_bottle(bottle_id: str, pair: BottlePair)
    +process_bottle_parallel(bottle_id: str, tap_bytes: bytes, level_bytes: bytes)
  }
}

package "app.azure_client" {
  class AzureClient <<module>> {
    +predict_tap_from_bytes_azure(image_bytes: bytes): (str, float)
    +predict_level_from_bytes_azure(image_bytes: bytes): (str, float)
  }
}

package "app.blob_client" {
  class BlobClient <<module>> {
    +list_blobs(container: str): list[str]
    +read_image_bytes(container: str, blob_name: str): bytes
    +upload_pdf(filename: str, pdf_bytes: bytes)
  }
}

package "app.pdf_generator" {
  class PdfGenerator <<module>> {
    +generate_error_pdf(...)
  }
}

package "app.pdf_receiver" {
  class PdfReceiver <<module>> {
    +upload_error_pdf(file)
  }
}

' --- Relacions d'ús (imports/calls) ---
WebSocketManager ..> WebSocket : uses

BottlePair ..> datetime : first_seen
Processor ..> ThreadPoolExecutor : executor

MainModule ..> manager : uses
MainModule ..> BlobWatcher : create_task(watch_containers)
MainModule ..> AzureClient : /api/analyze/* (mode manual)
MainModule ..> PdfReceiver : include_router

BlobWatcher ..> BlobClient : list_blobs
BlobWatcher ..> Processor : process_bottle_from_blobs

Processor ..> BlobClient : read_image_bytes, upload_pdf
Processor ..> AzureClient : predict_*_from_bytes_azure
Processor ..> manager : broadcast
Processor ..> PdfGenerator : generate_error_pdf
Processor --> BottlePair : uses

PdfReceiver ..> BlobClient : upload_pdf

note right of Processor
  Concurrència:
  - executor per crides síncrones (requests, blob download)
  - TAP i LEVEL en paral·lel (gather + timeout)
end note

note right of BlobClient
  upload_pdf(...) puja sempre al
  contenidor d'errors (CONTAINER_ERRORS)
end note

@enduml
